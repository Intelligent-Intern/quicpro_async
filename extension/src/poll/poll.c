/*
 * poll.c  –  Adaptive event-loop helper for php-quicpro
 * ------------------------------------------------------
 *
 * This file implements the core polling mechanism that drives QUIC
 * connections in PHP. It integrates with the quiche library to:
 *
 *   1) Drain inbound UDP packets from the kernel or a fast-path AF_XDP
 *      ring buffer and feed them into the quiche connection state machine.
 *   2) Collect outgoing packets generated by quiche and send them out
 *      over the network via sendto().
 *   3) Honor quiche’s built‑in connection and idle timeouts, invoking
 *      quiche_conn_on_timeout() when necessary.
 *   4) Extract kernel-provided RX/TX timestamps through socket
 *      ancillary data (SO_TIMESTAMPING_NEW) for precise RTT and jitter
 *      measurements.
 *   5) Optionally respect the system-wide NAPI busy-poll budget
 *      (net.core.busy_poll). If the budget is consumed, and we're running
 *      inside a PHP Fiber, yield back to the scheduler to prevent
 *      starving other fibers or blocking the PHP runtime.
 *
 * The high-level workflow of quicpro_poll() is:
 *   • Parse PHP function parameters and fetch the session resource.
 *   • Determine the next quiche timeout in milliseconds.
 *   • Enable socket timestamping (once per session).
 *   • Enter a busy-poll loop bounded by the smaller of:
 *       - The suggested quiche timeout (e.g., for handshake retransmits).
 *       - The NAPI busy-poll budget (if enabled).
 *   • Within each loop iteration:
 *       a) Drain incoming packets via AF_XDP (if compiled) and/or recvmsg().
 *       b) Process incoming QUIC datagrams via quiche_conn_recv().
 *       c) Send outgoing QUIC datagrams via quiche_conn_send() + sendto().
 *       d) Invoke quiche_conn_on_timeout() when the deadline is reached.
 *       e) Break or yield if budget expired or connection closed.
 *   • After the loop, refresh the TLS session ticket for export.
 *
 * This approach minimizes syscalls and context switches by busy-polling
 * when advised, yet cooperates with PHP’s Fiber scheduler when needed.
 *
 * Dependencies and Build Flags:
 *   • QUICPRO_XDP: enables AF_XDP fast-path for Linux kernel bypass.
 *   • QUICPRO_HAVE_NAPI_BUSY_POLL: reads /sys/kernel/net/napi_busy_poll
 *     to determine busy-poll budget in microseconds.
 *   • PHP_VERSION_ID: fiber integration varies by PHP version.
 */

#include "session.h"             /* Defines quicpro_session_t and le_quicpro_session */
#include "php_quicpro.h"         /* PHP_FUNCTION prototypes, error helpers */
#include <quiche.h>              /* quiche QUIC & HTTP/3 core API */

/*────────────────────────────── Fiber Support ─────────────────────────────*/

/*
 * PHP 8.4+ exposes zend_fiber_get_current() publicly, but some headers
 * may not declare it. PHP 8.1–8.3 use EG(current_fiber). PHP < 8.1
 * does not support fibers at all.
 *
 * This section conditionally declares or includes the appropriate API
 * to detect and suspend the current Fiber if we overshoot our busy-poll
 * budget. Yielding inside a Fiber allows other fibers to make progress
 * and prevents a tight C loop from blocking the PHP event loop.
 */

#if PHP_VERSION_ID >= 80400

/* New public API for getting the current Fiber instance */
typedef struct _zend_fiber zend_fiber;
extern zend_fiber *zend_fiber_get_current(void);
/* Suspend the current Fiber, returning control to the scheduler */
extern void zend_fiber_suspend(zend_fiber *fiber, zval *value, zval *return_value);

# define FIBER_GET_CURRENT()   zend_fiber_get_current()
# define FIBER_IS_ACTIVE()     (FIBER_GET_CURRENT() != NULL)
# define FIBER_SUSPEND()       zend_fiber_suspend(FIBER_GET_CURRENT(), NULL, NULL)

#elif PHP_VERSION_ID >= 80100 && PHP_VERSION_ID < 80400

# include <Zend/zend_fibers.h>
# ifdef ZEND_FIBER_G
#   define FIBER_GET_CURRENT()   (EG(current_fiber))
#   define FIBER_IS_ACTIVE()     (FIBER_GET_CURRENT() != NULL)
    /* No public suspend API in <=8.3, so fallback to userland (no-op) */
#   define FIBER_SUSPEND()       /* noop in C: see php8.3.fiber.md for workaround */
# else
#   define FIBER_GET_CURRENT()   NULL
#   define FIBER_IS_ACTIVE()     0
#   define FIBER_SUSPEND()       /* noop */
# endif

#else

# define FIBER_GET_CURRENT()   NULL
# define FIBER_IS_ACTIVE()     0
# define FIBER_SUSPEND()       /* noop */

#endif

/*──────────────────── quiche Compatibility Shims ──────────────────────────*/

/*
 * Some older quiche versions may not expose certain APIs. We provide
 * fallback definitions to allow compilation against older headers.
 */

#ifndef quiche_conn_get_tls_ticket
# define quiche_conn_get_tls_ticket(_c,_b,_l) 0
#endif

#ifndef quiche_conn_is_inactive
# define quiche_conn_is_inactive quiche_conn_is_draining
#endif

/*──────────────────────────── System Headers ──────────────────────────────*/

#include <errno.h>               /* errno and strerror() */
#include <fcntl.h>               /* open() */
#include <time.h>                /* clock_gettime() */
#include <sys/socket.h>          /* socket options, sendto(), recvmsg() */
#include <sys/time.h>            /* struct timeval */
#include <sys/select.h>          /* FD macros */
#include <linux/net_tstamp.h>    /* SOF_TIMESTAMPING flags */
#include <linux/errqueue.h>      /* MSG_ERRQUEUE constants */

#ifdef QUICPRO_HAVE_NAPI_BUSY_POLL
# include <stdatomic.h>          /* atomic caching of busy-poll budget */
#endif

#ifdef QUICPRO_XDP

/*
 * AF_XDP / XSK fast-path:
 *   • Bypass the kernel’s UDP stack to achieve lower latency and higher
 *     packet-per-second throughput.
 *   • We maintain an umem and RX/TX rings via libbpf’s xsk.
 *   • quicpro_xdp_drain() loops until no more packets are available,
 *     feeding each into quiche_conn_recv().
 */

# include <bpf/xsk.h>

static ssize_t quicpro_xdp_drain(quicpro_session_t *s)
{
    size_t packets = 0;
    uint32_t idx;

    /* Try to peek up to 64 descriptors at a time */
    while (xsk_ring_cons__peek(&s->rx, 64, &idx) == 64) {
        /* For each descriptor, pull the packet data and length */
        for (unsigned i = 0; i < 64; i++) {
            struct xdp_desc *d = xsk_ring_cons__comp_addr(&s->rx, idx + i);
            uint8_t *buf = xsk_umem__get_data(s->umem, d->addr);

            /* Build quiche_recv_info with source address */
            quiche_recv_info ri = {
                .from     = (struct sockaddr *)&s->peer,
                .from_len = sizeof(s->peer),
                .to       = NULL,
                .to_len   = 0
            };

            /* Deliver the packet to quiche */
            quiche_conn_recv(s->conn, buf, d->len, &ri);
            packets++;
        }

        /* Release the descriptors back to the producer ring */
        xsk_ring_cons__release(&s->rx, 64);
    }

    return packets;
}

#endif /* QUICPRO_XDP */

/*─────────────────────── Utility Inline Helpers ─────────────────────────*/

/*
 * quicpro_yield_if_needed()
 *
 * If our busy-poll budget (in µs) is exhausted and we are inside a Fiber,
 * yield control back to the PHP scheduler to avoid monopolizing CPU.
 * On PHP 8.4+, this will actually suspend the C Fiber;
 * on PHP 8.1–8.3, this is a no-op and userland code must cooperate.
 */
static inline void quicpro_yield_if_needed(int budget_us)
{
    if (budget_us <= 0 && FIBER_IS_ACTIVE()) {
        FIBER_SUSPEND();
    }
}

/*
 * quicpro_busy_budget_us()
 *
 * Reads /sys/kernel/net/napi_busy_poll (if available) to determine the
 * maximum busy-poll budget in microseconds. Subsequent calls return
 * a cached value to avoid repeated syscalls. If busy-poll is disabled
 * or unreadable, returns 0.
 */
static int quicpro_busy_budget_us(void)
{
#ifdef QUICPRO_HAVE_NAPI_BUSY_POLL
    static _Atomic int cached = -1;
    int val = atomic_load(&cached);

    if (val >= 0) {
        /* Already cached */
        return val;
    }

    /* Attempt to open the sysfs file */
    int fd = open("/sys/kernel/net/napi_busy_poll", O_RDONLY);
    if (fd < 0) {
        atomic_store(&cached, 0);
        return 0;
    }

    /* Read its contents into a small buffer */
    char buf[32] = {0};
    ssize_t n = read(fd, buf, sizeof(buf) - 1);
    close(fd);

    if (n <= 0) {
        atomic_store(&cached, 0);
        return 0;
    }

    /* Convert ASCII to integer */
    val = atoi(buf);
    atomic_store(&cached, val);
    return val;
#else
    /* Busy-poll not supported in this build */
    return 0;
#endif
}

/*
 * quicpro_perror()
 *
 * Convenience wrapper around php_error_docref to emit a warning
 * with the current errno and its string description.
 */
static inline void quicpro_perror(const char *ctx)
{
    php_error_docref(NULL, E_WARNING, "%s failed: %s", ctx, strerror(errno));
}

/*──────────────────────────── quicpro_poll() ─────────────────────────────*/

/**
 * quicpro_poll(resource $session, int $timeout_ms): bool
 *
 * Performs a single iteration (or busy-poll burst) of the QUIC event loop:
 *
 *   1) Parse parameters and fetch the session object.
 *   2) Ask quiche for the next deadline (in ms) for retransmit or idle.
 *   3) Enable socket-level timestamping once, to collect hardware/software
 *      RX/TX timestamps for ping and diagnostics.
 *   4) Determine the busy-poll budget by combining quiche deadline and
 *      NAPI busy-poll budget from the kernel.
 *   5) Enter a loop:
 *        a) Drain incoming packets (XDP and/or recvmsg).
 *        b) Feed each packet into quiche_conn_recv().
 *        c) Pull out and send any packets ready to go via quiche_conn_send().
 *        d) If quiche indicates the connection is draining/inactive, break.
 *        e) If a timeout event is due, call quiche_conn_on_timeout().
 *        f) If busy-poll budget is exceeded, yield if inside a Fiber.
 *   6) Once the loop ends, call quiche_conn_get_tls_ticket() to refresh
 *      the session ticket buffer for future export via PHP.
 *
 * Returns TRUE on success, FALSE on parameter/session errors.
 */
PHP_FUNCTION(quicpro_poll)
{
    zval      *zsess;
    zend_long  timeout_ms;

    /* Step 1: Parse PHP parameters: a resource and a millisecond timeout */
    if (zend_parse_parameters(ZEND_NUM_ARGS(), "rl", &zsess, &timeout_ms) == FAILURE) {
        RETURN_FALSE;
    }

    /* Fetch the C session pointer from the resource registry */
    quicpro_session_t *s =
        zend_fetch_resource(Z_RES_P(zsess), "quicpro", le_quicpro_session);
    if (!s) {
        /* Invalid resource passed */
        RETURN_FALSE;
    }

    /* Step 2: Determine quiche’s suggested timeout (ms) */
    int64_t quic_deadline = quiche_conn_timeout_as_millis(s->conn);
    if (quic_deadline >= 0 && (timeout_ms < 0 || quic_deadline < timeout_ms)) {
        timeout_ms = quic_deadline;
    }

    /* Step 3: Enable socket timestamping exactly once per session */
    if (!s->ts_enabled) {
        int flags = SOF_TIMESTAMPING_SOFTWARE
                  | SOF_TIMESTAMPING_RX_SOFTWARE
                  | SOF_TIMESTAMPING_TX_SOFTWARE
                  | SOF_TIMESTAMPING_RAW_HARDWARE;
        if (setsockopt(s->sock, SOL_SOCKET, SO_TIMESTAMPING_NEW,
                       &flags, sizeof(flags)) == 0) {
            s->ts_enabled = 1;
        }
    }

    /* Step 4: Calculate busy-poll budget in microseconds */
    int            budget_us = quicpro_busy_budget_us();
    struct timespec start_ts;
    clock_gettime(CLOCK_MONOTONIC_RAW, &start_ts);

    /* Step 5: Enter busy-poll loop */
    while (1) {
        /* ==== Receive path ==== */

#ifdef QUICPRO_XDP
        /* If AF_XDP enabled, first drain packets from XDP ring */
        quicpro_xdp_drain(s);
#endif

        {
            /* Fallback UDP recv via recvmsg(MMSG) for timestamping */
            uint8_t buf[65535];
            struct sockaddr_storage from;
            struct iovec iov = { .iov_base = buf, .iov_len = sizeof(buf) };
            char cbuf[512];

            struct msghdr msg = {
                .msg_name       = &from,
                .msg_namelen    = sizeof(from),
                .msg_iov        = &iov,
                .msg_iovlen     = 1,
                .msg_control    = cbuf,
                .msg_controllen = sizeof(cbuf),
            };

            /* Non-blocking receive; MSG_DONTWAIT avoids blocking */
            ssize_t n = recvmsg(s->sock, &msg, MSG_DONTWAIT);
            if (n > 0) {
                /* Wrap sockaddr in quiche_recv_info */
                quiche_recv_info ri = {
                    .from     = (struct sockaddr *)&from,
                    .from_len = msg.msg_namelen,
                    .to       = NULL,
                    .to_len   = 0
                };
                /* Deliver packet to quiche */
                quiche_conn_recv(s->conn, buf, n, &ri);

                /* Parse control messages for RX timestamp */
                for (struct cmsghdr *cm = CMSG_FIRSTHDR(&msg); cm;
                     cm = CMSG_NXTHDR(&msg, cm)) {
                    if (cm->cmsg_level == SOL_SOCKET &&
                        cm->cmsg_type  == SO_TIMESTAMPING_NEW) {
                        s->last_rx_ts = *(struct timespec *)CMSG_DATA(cm);
                        break;
                    }
                }
            } else if (n < 0 && errno != EAGAIN && errno != EWOULDBLOCK) {
                /* Unexpected error in recvmsg; warn and continue */
                quicpro_perror("recvmsg");
            }
        }

        /* ==== Transmit path ==== */
        while (1) {
            uint8_t out[1350];
            quiche_send_info si;
            /* Ask quiche for the next packet to send */
            ssize_t out_len =
                quiche_conn_send(s->conn, out, sizeof(out), &si);
            if (out_len <= 0) {
                /* No more packets ready */
                break;
            }
            /* Send the packet to the remote address provided by quiche */
            ssize_t sent = sendto(s->sock, out, out_len, 0,
                                  (const struct sockaddr *)&si.to,
                                  si.to_len);
            if (sent < 0) {
                quicpro_perror("sendto");
                break;
            }
        }

        /* ==== Timeout and shutdown checks ==== */

        /* If quiche signals the connection is inactive or draining, exit */
        if (quiche_conn_is_inactive(s->conn)) {
            break;
        }
        /* If the timeout has arrived, process it inside quiche */
        if (quiche_conn_timeout_as_millis(s->conn) == 0) {
            quiche_conn_on_timeout(s->conn);
        }

        /* ==== Budget enforcement and optional Fiber yield ==== */

        struct timespec now_ts;
        clock_gettime(CLOCK_MONOTONIC_RAW, &now_ts);
        int elapsed_us = (now_ts.tv_sec  - start_ts.tv_sec)  * 1000000
                       + (now_ts.tv_nsec - start_ts.tv_nsec) / 1000;
        if (elapsed_us >= budget_us) {
            /* We have exceeded the busy-poll budget; yield if needed */
            quicpro_yield_if_needed(elapsed_us - budget_us);
            break;
        }
    }

    /* Step 6: Refresh TLS session ticket for export via PHP API */
    s->ticket_len = quiche_conn_get_tls_ticket(s->conn,
                                              s->ticket,
                                              sizeof(s->ticket));

    RETURN_TRUE;
}
